<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="https://purl.org/rss/1.0/modules/content/"
	xmlns:dc="https://purl.org/dc/elements/1.1/"
	xmlns:atom="https://www.w3.org/2005/Atom"
	xmlns:sy="https://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>
	Comments on: Rendering React components to the document body	</title>
	<atom:link href="/rendering-react-components-to-the-document-body/feed/" rel="self" type="application/rss+xml" />
	<link>/rendering-react-components-to-the-document-body/</link>
	<description></description>
	<lastBuildDate>Tue, 27 Sep 2016 14:26:04 +0000</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.9.3</generator>
	<item>
		<title>
		By: Ariel Ferro		</title>
		<link>/rendering-react-components-to-the-document-body/#comment-23499</link>

		<dc:creator><![CDATA[Ariel Ferro]]></dc:creator>
		<pubDate>Tue, 27 Sep 2016 14:26:04 +0000</pubDate>
		<guid isPermaLink="false">/?p=16#comment-23499</guid>

					<description><![CDATA[In reply to &lt;a href=&quot;/rendering-react-components-to-the-document-body/#comment-17425&quot;&gt;John&lt;/a&gt;.

sometimes that could be not an option]]></description>
			<content:encoded><![CDATA[<p>In reply to <a href="/rendering-react-components-to-the-document-body/#comment-17425">John</a>.</p>
<p>sometimes that could be not an option</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Steven Sanborn		</title>
		<link>/rendering-react-components-to-the-document-body/#comment-22877</link>

		<dc:creator><![CDATA[Steven Sanborn]]></dc:creator>
		<pubDate>Sun, 21 Aug 2016 05:01:49 +0000</pubDate>
		<guid isPermaLink="false">/?p=16#comment-22877</guid>

					<description><![CDATA[This is great and it seems like a work around to render to a non React dom node generated by js. 

also saw this one :

https://github.com/Khan/react-components/blob/master/js/layered-component-mixin.jsx]]></description>
			<content:encoded><![CDATA[<p>This is great and it seems like a work around to render to a non React dom node generated by js. </p>
<p>also saw this one :</p>
<p><a href="https://github.com/Khan/react-components/blob/master/js/layered-component-mixin.jsx" rel="nofollow ugc">https://github.com/Khan/react-components/blob/master/js/layered-component-mixin.jsx</a></p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Jason		</title>
		<link>/rendering-react-components-to-the-document-body/#comment-21846</link>

		<dc:creator><![CDATA[Jason]]></dc:creator>
		<pubDate>Fri, 08 Jul 2016 21:00:05 +0000</pubDate>
		<guid isPermaLink="false">/?p=16#comment-21846</guid>

					<description><![CDATA[In reply to &lt;a href=&quot;/rendering-react-components-to-the-document-body/#comment-21845&quot;&gt;Jason&lt;/a&gt;.

This is what I ended up doing in order to get it to update my child component with the new props, however it won&#039;t be using the virtual dom anymore with this way. Does anyone have ideas on how we can get this to work the right way? The componentDidUpdate is where my main concerns lie. Everything else seems to work fine from what I can tell.

export class RenderInBody extends React.Component {
    private container: Element;
    private child: any;

    componentDidMount() {
        this.container = document.createElement(&quot;div&quot;);
        document.body.appendChild(this.container);
        this.child = ReactDOM.render(this.props.children, this.container);
    }

    componentDidUpdate() {
        if (!this.child) return;
        this.child = ReactDOM.render(this.props.children, this.container);
        this.child.setState({});
    }

    componentWillUnmount() {
        ReactDOM.unmountComponentAtNode(this.container);
        document.body.removeChild(this.container);
    }

    render() {
        return null;
    }
}]]></description>
			<content:encoded><![CDATA[<p>In reply to <a href="/rendering-react-components-to-the-document-body/#comment-21845">Jason</a>.</p>
<p>This is what I ended up doing in order to get it to update my child component with the new props, however it won&#8217;t be using the virtual dom anymore with this way. Does anyone have ideas on how we can get this to work the right way? The componentDidUpdate is where my main concerns lie. Everything else seems to work fine from what I can tell.</p>
<p>export class RenderInBody extends React.Component {<br />
    private container: Element;<br />
    private child: any;</p>
<p>    componentDidMount() {<br />
        this.container = document.createElement(&#8220;div&#8221;);<br />
        document.body.appendChild(this.container);<br />
        this.child = ReactDOM.render(this.props.children, this.container);<br />
    }</p>
<p>    componentDidUpdate() {<br />
        if (!this.child) return;<br />
        this.child = ReactDOM.render(this.props.children, this.container);<br />
        this.child.setState({});<br />
    }</p>
<p>    componentWillUnmount() {<br />
        ReactDOM.unmountComponentAtNode(this.container);<br />
        document.body.removeChild(this.container);<br />
    }</p>
<p>    render() {<br />
        return null;<br />
    }<br />
}</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Jason		</title>
		<link>/rendering-react-components-to-the-document-body/#comment-21845</link>

		<dc:creator><![CDATA[Jason]]></dc:creator>
		<pubDate>Fri, 08 Jul 2016 20:48:50 +0000</pubDate>
		<guid isPermaLink="false">/?p=16#comment-21845</guid>

					<description><![CDATA[In reply to &lt;a href=&quot;/rendering-react-components-to-the-document-body/#comment-19185&quot;&gt;Richard&lt;/a&gt;.

I am also experiencing issues with the componentDidUpdate() here. It seems the example works excellent up to the point where if something updates. My props aren&#039;t getting passed down into the child component. Is this what you were seeing also? What did you have to do to fix this?]]></description>
			<content:encoded><![CDATA[<p>In reply to <a href="/rendering-react-components-to-the-document-body/#comment-19185">Richard</a>.</p>
<p>I am also experiencing issues with the componentDidUpdate() here. It seems the example works excellent up to the point where if something updates. My props aren&#8217;t getting passed down into the child component. Is this what you were seeing also? What did you have to do to fix this?</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Richard		</title>
		<link>/rendering-react-components-to-the-document-body/#comment-19185</link>

		<dc:creator><![CDATA[Richard]]></dc:creator>
		<pubDate>Mon, 02 May 2016 18:36:40 +0000</pubDate>
		<guid isPermaLink="false">/?p=16#comment-19185</guid>

					<description><![CDATA[In reply to &lt;a href=&quot;/rendering-react-components-to-the-document-body/#comment-690&quot;&gt;Mark Allen&lt;/a&gt;.

This didn&#039;t seem to work with your componentDidUpdate function.  I had to put the ReactDom.render back in.]]></description>
			<content:encoded><![CDATA[<p>In reply to <a href="/rendering-react-components-to-the-document-body/#comment-690">Mark Allen</a>.</p>
<p>This didn&#8217;t seem to work with your componentDidUpdate function.  I had to put the ReactDom.render back in.</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: John		</title>
		<link>/rendering-react-components-to-the-document-body/#comment-17425</link>

		<dc:creator><![CDATA[John]]></dc:creator>
		<pubDate>Mon, 04 Apr 2016 22:29:02 +0000</pubDate>
		<guid isPermaLink="false">/?p=16#comment-17425</guid>

					<description><![CDATA[Hi, I&#039;m curious what benefits/drawbacks this has compared to using CSS like position: fixed?]]></description>
			<content:encoded><![CDATA[<p>Hi, I&#8217;m curious what benefits/drawbacks this has compared to using CSS like position: fixed?</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Jean		</title>
		<link>/rendering-react-components-to-the-document-body/#comment-5950</link>

		<dc:creator><![CDATA[Jean]]></dc:creator>
		<pubDate>Mon, 21 Dec 2015 22:57:34 +0000</pubDate>
		<guid isPermaLink="false">/?p=16#comment-5950</guid>

					<description><![CDATA[In reply to &lt;a href=&quot;/rendering-react-components-to-the-document-body/#comment-5949&quot;&gt;Jean&lt;/a&gt;.

Ok I was misunderstanding. This piece of code is to make sure that the child component (popup) is destroyed when the parent unmounts. Not as I thought a helper to create/destroy only the popup. But is will be a good basis for this purpose anyhow.
Thanks for this post.]]></description>
			<content:encoded><![CDATA[<p>In reply to <a href="/rendering-react-components-to-the-document-body/#comment-5949">Jean</a>.</p>
<p>Ok I was misunderstanding. This piece of code is to make sure that the child component (popup) is destroyed when the parent unmounts. Not as I thought a helper to create/destroy only the popup. But is will be a good basis for this purpose anyhow.<br />
Thanks for this post.</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Jean		</title>
		<link>/rendering-react-components-to-the-document-body/#comment-5949</link>

		<dc:creator><![CDATA[Jean]]></dc:creator>
		<pubDate>Mon, 21 Dec 2015 22:43:54 +0000</pubDate>
		<guid isPermaLink="false">/?p=16#comment-5949</guid>

					<description><![CDATA[Hi, this solution definitely looks like what I need to handle dialogs.
But I don&#039;t really get it... what should the dialog do to unmount the RenderInBody component?
In other words, how do we get to have &quot;componentWillUnmount&quot; called?
Thanks!]]></description>
			<content:encoded><![CDATA[<p>Hi, this solution definitely looks like what I need to handle dialogs.<br />
But I don&#8217;t really get it&#8230; what should the dialog do to unmount the RenderInBody component?<br />
In other words, how do we get to have &#8220;componentWillUnmount&#8221; called?<br />
Thanks!</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Mark Allen		</title>
		<link>/rendering-react-components-to-the-document-body/#comment-690</link>

		<dc:creator><![CDATA[Mark Allen]]></dc:creator>
		<pubDate>Tue, 07 Jul 2015 02:24:44 +0000</pubDate>
		<guid isPermaLink="false">/?p=16#comment-690</guid>

					<description><![CDATA[Nice post James! My team wanted to do something like this so we could add popover/drop-down options to components without worrying if all their containing elements had the proper CSS styles (overflow visible, relative position, etc). We decided it would be more consistent to render straight to the document body and position the popovers with javascript. 

Although this is a relatively old post (in React time), because we used this code sample as a starting point for our solution, I wanted to point out one small, but consequential pitfall of the approach:

When you call &lt;code&gt;React.render(this.props.children, this.popup);&lt;/code&gt; every time, you miss out on many of the great parts of React like the virtual DOM, it&#039;s speed, and the diffing that occurs when the component is re-rendered into the DOM.

The approach we settled on involves saving a reference to the rendered component when we render it into the DOM on &lt;code&gt;componentDidMount&lt;/code&gt;. We can then &lt;code&gt;setState&lt;/code&gt; whenever the component receives updates, and utilize the power of React&#039;s virtual DOM! Only the elements that have changed will be updated.

&lt;code&gt;
componentDidMount: function () {
  this._container = document.createElement(&quot;div&quot;);
  document.body.appendChild(this._container);
  this._child = React.render(this.props.children, this._container);
},

componentDidUpdate: function () {
  if (!this._child) return;

  this._child.setState({});
},

componentWillUnmount: function () {
  React.unmountComponentAtNode(this._container);
  document.body.removeChild(this._container);
}
&lt;/code&gt;

Works like a charm. Integration remains exactly the same as the code you posted.

In other news, I also learned today that you can return &lt;code&gt;null&lt;/code&gt; from a component&#039;s render function instead of an empty div! React will render an empty noscript tag into the DOM instead of the empty div, so you can be completely sure it does nothing (:

&lt;code&gt;
render: function () {
  return null;
}
&lt;/code&gt;

Thanks again!]]></description>
			<content:encoded><![CDATA[<p>Nice post James! My team wanted to do something like this so we could add popover/drop-down options to components without worrying if all their containing elements had the proper CSS styles (overflow visible, relative position, etc). We decided it would be more consistent to render straight to the document body and position the popovers with javascript. </p>
<p>Although this is a relatively old post (in React time), because we used this code sample as a starting point for our solution, I wanted to point out one small, but consequential pitfall of the approach:</p>
<p>When you call <code>React.render(this.props.children, this.popup);</code> every time, you miss out on many of the great parts of React like the virtual DOM, it&#8217;s speed, and the diffing that occurs when the component is re-rendered into the DOM.</p>
<p>The approach we settled on involves saving a reference to the rendered component when we render it into the DOM on <code>componentDidMount</code>. We can then <code>setState</code> whenever the component receives updates, and utilize the power of React&#8217;s virtual DOM! Only the elements that have changed will be updated.</p>
<p><code><br />
componentDidMount: function () {<br />
  this._container = document.createElement("div");<br />
  document.body.appendChild(this._container);<br />
  this._child = React.render(this.props.children, this._container);<br />
},</p>
<p>componentDidUpdate: function () {<br />
  if (!this._child) return;</p>
<p>  this._child.setState({});<br />
},</p>
<p>componentWillUnmount: function () {<br />
  React.unmountComponentAtNode(this._container);<br />
  document.body.removeChild(this._container);<br />
}<br />
</code></p>
<p>Works like a charm. Integration remains exactly the same as the code you posted.</p>
<p>In other news, I also learned today that you can return <code>null</code> from a component&#8217;s render function instead of an empty div! React will render an empty noscript tag into the DOM instead of the empty div, so you can be completely sure it does nothing (:</p>
<p><code><br />
render: function () {<br />
  return null;<br />
}<br />
</code></p>
<p>Thanks again!</p>
]]></content:encoded>
		
			</item>
	</channel>
</rss>
